<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Using MongoDB as a Semantic Data</title>
</head>

<body>

<p><img border="0" src="testResults.png" width="369" height="381"></p>
<h2>Using MongoDB to Implement a Semantic Database - Part I</h2>
<p>As I've written previously:</p>
<p>
<a href="http://www.codeproject.com/Articles/832959/Semantic-Database-Concept-Architecture-and-Impleme">
Semantic Database: Concept, Architecture and Implementation</a><br>
<a href="http://www.codeproject.com/Articles/837878/The-Semantic-Database-In-Action">
The Semantic Database In Action</a><br>
<a href="http://www.codeproject.com/Articles/1077839/Working-with-MongoDBs-lookup-Aggregator">
Working with MongoDB's $lookup Aggregator</a></p>
<p>semantic databases are a new kind of database store.&nbsp; Because such a 
database engine does not yet exist, we have to build it on top of existing 
engines.&nbsp; In my previous articles, I discussed how a semantic database 
could be built on top of a SQL database.&nbsp; In this article, we will explore 
how a semantic database can be built on top of a NoSQL database, specifically 
MongoDB, and illustrate some of the advantages of using a NoSQL database.</p>
<p>With the advent in December 2015 of MongoDB version 3.2, this became much 
easier (and realistic) to do, because version 3.2 supports left outer joins with 
the $lookup aggregator.</p>
<p>This article covers creating basic CRUD operations in MongoDB for a semantic 
database.</p>
<p>Part II will cover a real world example and will undoubtedly <i>uncover</i> 
implementation flaws in this article.&nbsp; While Part I covers working with the 
relational hierarchy of a single semantic type, Part II will cover working with 
the relationships <i>between</i> semantic types.</p>
<p>Part III will be a surprise!
<img border="0" src="smiley.png" width="32" height="32"></p>
<h3>Where's the Code?</h3>
<p>The code is on GitHub:
<a href="https://github.com/cliftonm/mongodbSemanticDatabase">
https://github.com/cliftonm/mongodbSemanticDatabase</a> </p>
<p>As this is an evolving effort, please download the latest code from there.&nbsp; 
For example, some of the use of Newtonsoft (particularly <code>JObject</code>) that exists in 
this article has already been replaces with <code>BsonDocument</code> in the latest 
implementation and tests.</p>
<h2>The Foundational Concepts of a Semantic Database</h2>
<p>Fundamentally, a semantic database captures relationships.&nbsp; There are 
two primary kinds of relationships::</p>
<ol>
	<li>Static, implicit relationships that define the structure (give meaning) 
	to a semantic term (a symbol).&nbsp; These are typically expressed with the 
	same terms used in object oriented programming &quot;has a&quot; and &quot;is a kind of.&quot;</li>
	<li>Static or dynamic explicit relationships, where the relationship itself 
	has a meaning expressed in a semantic term and where dynamic relationships 
	can change over time.&nbsp; In programming, these relationships are usually 
	expressed implicitly in the code, for example, a dictionary or other 
	key-value pair collections.&nbsp; Dynamic relationships often have a time 
	frame -- a beginning and an ending.</li>
</ol>
<p>I've written about explicit dynamic relationships in my series on 
Relationship Oriented Programming:</p>
<p><a href="http://www.codeproject.com/Articles/294402/Romeo-and-Juliet">Romeo 
and Juliet</a><br>
<a href="http://www.codeproject.com/Articles/298818/Relationship-Oriented-Programming">
Relationship Oriented Programming</a><br>
<a href="http://www.codeproject.com/Articles/307638/Do-You-Really-Want-To-Be-Agile">
Do You Really Want to be Agile?</a><br>
<a href="http://www.codeproject.com/Articles/327289/ROP">Relationship Oriented 
Programming&nbsp; - the IDE plus More on Agile Project Management</a></p>
<p>A semantic database actually combines the qualities of semantics and 
relationality, as we will demonstrate here.</p>
<h3>An Example of a Static, Implicit Semantic Relationship</h3>
<p>A person's name is a good example of implicit semantic relationships.&nbsp; 
People's names (but not in all cultures and of course there are variances even 
within a culture) consist of a first name and last name.&nbsp; The symbols 
&quot;first name&quot; and &quot;last name&quot; are themselves specializations of the symbol 
&quot;name&quot;.&nbsp; Finally, the symbol &quot;name&quot; is a specialization of the symbol (in 
this data type) &quot;string.&quot;&nbsp; These are all &quot;has a&quot; and &quot;is a kind of&quot; 
relationships.</p>
<h3>Examples of an Explicit Relationship</h3>
<p>Relationships exist between specialized semantic types, and we can 
sub-categorize them into static and dynamic relationships..</p>
<h4>Examples of a Static Relationship</h4>
<p>Fixed relationships are those that never change over time.&nbsp; For example, 
a person always has a relationship to two other people, &quot;mother&quot; and &quot;father.&quot;&nbsp; 
During a person's lifetime, there is a static relationship between the person 
and their birth sign (Leo, Gemini, etc.)&nbsp; Of course, the stars that make up 
that constellation are actually in a dynamic relationship.&nbsp; </p>
<h4>Examples of a Dynamic Relationship </h4>
<p>In contrast to a static relationship, not every person has a son or daughter.&nbsp; 
This relationship may come into existence, and when it does, it's associated 
with a particular timestamp.&nbsp; A person's name can be a dynamic relationship 
-- consider nicknames and aliases.&nbsp; Ownership, residence, marriage, 
religious affiliation, rap sheet, party affiliation -- these are are example of 
potentially dynamic relationships.&nbsp; Most relationships are dynamic, 
occurring (and possibly recurring) in a particular time interval.</p>
<h4>Explicit Relationships are Themselves Semantic </h4>
<p>Relationships such as &quot;mother&quot;, &quot;daughter&quot;, &quot;Republican&quot;, &quot;Buddhist&quot; are 
semantic.&nbsp; They express either a relationship or a state, so that we can 
say:</p>
<p>&quot;[X] is the [Y] of [Z]&quot;&nbsp; -- expresses the relationship, as in, &quot;Marc is 
the son of Elisabeth&quot;</p>
<p>or</p>
<p>&quot;[X] is a [Y]&quot;&nbsp; -- expresses a relational state, as in, &quot;Marc is an 
Anthroposophist&quot;</p>
<p>or</p>
<p>&quot;[X] [Y] [Z]&quot;&nbsp; -- expresses an activity, as in &quot;Marc owns a cat&quot;</p>
<p>These are all semantically (haha) describing relationships.&nbsp; When we say 
something stateful, such as &quot;[X] is a [Y]&quot;, we can convert this to a 
prepositional phrase to describe the relationship, becoming &quot;[X] is [Z] with 
[Y]&quot; or similar, though you may have to exercise your imagination a bit.&nbsp; 
For example, &quot;Marc is a man&quot;, as a state of being, can be described relationally 
as &quot;Marc is a human with male gender&quot;, or &quot;Marc has the gender male.&quot;&nbsp; In 
either case, we've done something useful -- we've identified a class of state 
(gender) that lets us describe explicitly the relationship between Marc and a 
gender.&nbsp; Enough though with language semantics!</p>
<h3>Structural Relationship and Symbol Relationship</h3>
<p>A semantic database must capture both the hierarchy, the structure, of a 
symbol as well as the symbol's relationship to other symbols.&nbsp; If, for 
example, we have two symbols, one for a person's name and another for an 
address, we can easily query for atypical relationships: &quot;give me all the people 
who's first names are also street names in the town they live in.&quot;&nbsp; </p>
<h4>The advantage of a NoSQL Database</h4>
<p>While this is a query one can easily imagine in a SQL database, it assumes 
that the schema already exists in which to make this query.&nbsp; The advantage 
of a NoSQL database is that the schema itself is dynamic:</p>
<ol>
	<li>The structure of implicit symbols change (think of how names and 
	addresses vary among cultures.)</li>
	<li>New symbols can be easily added (simply add a new collection.)</li>
	<li>New relationships between symbols can be easily added (simply add a 
	collection with two fields associating the ID's of two collections.)</li>
</ol>
<p>In a SQL database, this would require manipulating the schema, whereas in a 
NoSQL database, this is unnecessary (though one still wants to pay attention to 
indexing for performance reasons.)</p>
<p>Using a NoSQL database eliminates a considerable amount of the work required 
in simulating a true semantic database, but as mentioned earlier, until the 
advent of the $lookup aggregator, doing so was relegated to the client-side 
implementation rather than the being handled by the server-side.&nbsp; Handling 
it on the client-side was not, in our opinion, a feasible solution because of 
the memory and bandwidth required to pull across all the records of one 
collection simply to eliminate many of them with a left join of another 
collection, which also had to be read fully into client-side memory.&nbsp; 
Happily, the MongoDB $lookup aggregator solves that problem.</p>
<h4>A NoSQL Database is Still Not a Semantic Database</h4>
<p>There is still considerable work that needs to be done (as is also true for a 
SQL database), but that work is really only in the realm of:</p>
<ul>
	<li>creating collections</li>
	<li>creating the queries dynamically at runtime</li>
	<li>maintaining a normalized database</li>
	<li>reference counting<ul>
		<li>handling inserts so that data is not duplicated</li>
		<li>handling deletes so that data being referenced by other collections 
		is not deleted until the number of references is 0</li>
		<li>handling updates so that data being referenced by other collections 
		is maintained and only the parent reference changes</li>
	</ul>
	</li>
</ul>
<h4>Normalized vs. Denormalized Data in a Semantic Database</h4>
<p>A NoSQL database easily handles denormalized database--a sub-document within 
a document.&nbsp; It is of course easy to create a denormalized schema in a SQL 
database as well, which is the bane of most legacy databases.&nbsp; The golden 
rule with a semantic database is:</p>
<ul>
	<li>All data in normalized!</li>
</ul>
<p>A semantic database relies on the fact that the data is normalized -- a 
relationship between two symbols is based on a many-to-many relationship 
collection.&nbsp; It is NOT built on comparing field values.&nbsp; Using the 
person name and street address example earlier, a typical SQL query would look 
like this:</p>
<pre>select * from Person p
left join Address a on a.StreetName = p.FirstName</pre>
<p>A <i>semantic</i> query looks like this (in SQL):</p>
<pre>select * from Name n                                  -- Name symbol
left join FirstName fn on fn.NameId = n.Id            -- n:m collection
left join PersonName pn on pn.FirstNameId = n.NameId  -- n:m collection
left join Person p on p.Id = pn.PersonId              -- Person symbol, having a Name association through &quot;pn&quot;
left join StreetName sn on sn.NameId = n.Id           -- n:m collection
left join AddressStreetName asn on asn.StreetNameId = sn.Id -- n:m collection
left join Address a on a.Id = asn.AddressId           -- Address symbol, having a StreetName association through &quot;asn&quot;</pre>
<p>This looks horrid (and I'm not sure I even got it right), and it is, but it 
expresses both the semantic structure and the relationship between two otherwise 
unrelated symbols:</p>
<p><img border="0" src="sql1.png" width="584" height="260"></p>
<h4>So What's the Point?</h4>
<p><img border="0" src="key-small.jpg" width="94" height="33"></p>
<p>The point is that with a semantic database, relationships that are not 
explicit between two symbols can still be queried.&nbsp; One can, for example, 
ask of a semantic database:  </p>
<ul>
	<li>can I relate a Person and an Address via the person's first name?</li>
	<li>what are the ways I can relate a Person and an Address other than an 
	explicit relationship?&nbsp;&nbsp;&nbsp; </li>
</ul>
<p>A semantic database can recurse through the semantic structure to discover 
(and validate) new ways of relating data!&nbsp; A non-semantic database (whether 
in SQL or NoSQL) simply cannot do that, because there is no discoverable path 
from &quot;FirstName&quot; to &quot;StreetName&quot;.&nbsp; </p>
<p><img border="0" src="key-small.jpg" width="94" height="33"></p>
<p>A semantic database stand apart from the rest of the database world in its 
ability to discover new relationships based not on explicitly defined structural 
or dynamic relationships but on relationships that result in shared semantics..</p>
<h4>Applications</h4>
<p>Three applications come to mind immediately:</p>
<ol>
	<li>Big Data</li>
	<li>Internet of Things</li>
	<li>Records Management</li>
</ol>
<p>The analysis of Big Data (&quot;data sets so large or complex that traditional 
data processing applications are inadequate&quot; --
<a href="https://en.wikipedia.org/wiki/Big_data">
https://en.wikipedia.org/wiki/Big_data</a>) is, in my uninformed opinion, still 
reliant on human beings explicitly determining the relationships between data 
sets.&nbsp; A semantic database could easily be queried for previously unknown 
relationships, as well as facilitating the association of disparate data sets 
with explicit relational meaning.</p>
<p>Second, as with Big Data, the Internet of Things is going to be generating 
vast amounts of data.&nbsp; In my opinion, the only way to successfully 
correlate that data into something that has meaning beyond the initial dataset 
is to make it semantic and store it in a semantic database.</p>
<p>Records Management (things like medical, emergency, criminal) is already a 
vast, messy, and uncorrelated system of information.&nbsp; Furthermore, it is 
always changing:</p>
<ul>
	<li>in schema -- the information people want to track</li>
	<li>in lifecycle -- illnesses come (and hopefully go), fires are put out, 
	people commit new crimes, etc...</li>
	<li>in relationship -- relationships between people and things are always 
	changing</li>
</ul>
<p>A semantic database is a solution to the critical problem of diverse, 
incompatible, and limited databases that currently hold our public and 
not-so-private information.</p>
<h2>Implementation</h2>
<p>As stated earlier, in a true semantic database, we could ask these &quot;can I 
relate...&quot; and &quot;give me the intersection of ...&quot; questions and have the 
server-side do the heavy lifting.&nbsp; But since a true semantic database 
doesn't exist, we have to do that heavy lifting ourselves.&nbsp; But first, we 
have to implement the core functionality.&nbsp; Part II will explore the more 
interesting things we can do with a semantic database.</p>
<h3>What You'll Needd</h3>
<p>If you've never used MongoDB with C#, you'll need to:</p>
<ul>
	<li><a href="https://www.mongodb.org/downloads#production">Download</a> and 
	install the MongoDB server</li>
	<li><a href="https://mongodb.github.io/mongo-csharp-driver/">Download</a> 
	and install the 2.2.0 or greater MongoDB .NET Driver</li>
	<li>Run the MongoDB server, <code>mongod.exe</code>, either in a console window or as a 
	service<ul>
		<li>The 3.2 64 bit version of <code>mongod.exe</code> is typically found in <code>C:\Program Files\MongoDB\Server\3.2\bin</code></li>
	</ul>
	</li>
	<li>Optionally <a href="http://app.robomongo.org/">download</a> and install 
	RoboMongo, so you can inspect your collections in a nice GUI.</li>
</ul>
<h3>Test Driven Development</h3>
<p>This is a good usage of test driven development, as we can state a lot about 
the preconditions, functions, and post-conditions that we expect from a semantic 
database.&nbsp; As we implement each unit test, adding new behavioral 
requirements, and implementing the methods to get the test to pass, you'll 
notice that sometimes the previous tests and usually the implementation are 
frequently refactored.&nbsp; These are the tests, conceptually, that we want to perform (the term &quot;collection&quot; 
refers here to a NoSQL collection):</p>
<ol>
	<li>Creation of a concrete semantic type collectionn</li>
	<li>Creation of a hierarchical semantic type, demonstrating how non-concrete 
	specializations (sounds like an oxymoron) results in both concrete and 
	many-to-many relationship collections</li>
	<li>Define relationships between semantic types with a many-to-many 
	relationship collection</li>
	<li>Relationships:<ol>
		<li>Be able to ask &quot;what are explicit relationships of a semantic type?&quot;</li>
		<li>Be able to ask &quot;what are discoverable (implicit) relationships of a 
		semantic type?&quot;</li>
		<li>Be able to ask &quot;what is the structure of this semantic type?&quot;</li>
	</ol>
	</li>
	<li>For both concrete and specialized semantic types:<ol>
		<li>Insert: creating automatically the many-to-many relationship 
		instance documents and concrete collection documents.</li>
		<li>Update:
		<ol>
			<li>updating a singleton document</li>
			<li>decoupling a document with multiple references into two discrete 
			documents and updating many-to-many references</li>
		</ol>
		</li>
		<li>Delete:<ol>
			<li>deleting a singleton document and its hierarchy</li>
			<li>deleting hierarchy collections only when a document is 
			referenced by more than one specialized semantic instance</li>
		</ol>
		</li>
		<li>Query:<ol>
			<li>Query a concrete semantic type</li>
			<li>Query a specialized concrete type, auto-generating the joins to 
			resolve down to the concrete instance</li>
			<li>Query two or more semantic types, auto-generating the joins to 
			associate the semantic types</li>
		</ol>
		</li>
	</ol>
	</li>
</ol>
<h3>Naming Conventions</h3>
<p>The following naming conventions are used:</p>
<ul>
	<li>collection and database names are Camel case (the first letter of an 
	identifier is lowercase and the first letter of each subsequent concatenated 
	word is capitalized.)</li>
	<li>collections are singular in name</li>
	<li>field names are Camel case</li>
	<li>many-to-many collections<ul>
		<li>singular name</li>
		<li>the two collection objects referenced are separated by an underscore</li>
		<li>the ID's binding the collections in the form:<ul>
			<li>[collectionName1]Id</li>
			<li>[collectionName2]Id</li>
		</ul>
		</li>
	</ul>
	</li>
</ul>
<h3>Creation of a Concrete Semantic Type Collection</h3>
<p>We'll start with creating some concrete semantic types.&nbsp; A concrete 
semantic type usually describes a single concrete type, so it's pretty basic.&nbsp; 
There is a always a question with regards to the extreme of creating a concrete 
type.&nbsp; For example, we can define a phone number:</p>
<p>PhoneNumber: string (or even number)</p>
<p>or:</p>
<ul>
	<li>phoneNumber<ul>
		<li>countryCode : int</li>
		<li>areaCode : int</li>
		<li>exchange : int</li>
	<li>subscriberId : int</li>
	</ul>
</li>
</ul>
<p>or:</p>
<ul>
	<li>phoneNumber<ul>
		<li>countryCode<ul>
			<li>number : int</li>
		</ul>
	</li>
	<li>areaCode<ul>
		<li>number : int</li>
	</ul>
	</li>
	<li>exchange<ul>
			<li>number : int</li>
		</ul>
	</li>
	<li>subscriberId<ul>
		<li>number : int</li>
		</ul>
		</li>
	</ul>
	</li>
</ul>
<p>No, we will not break down &quot;number&quot; into bits 0-32!&nbsp; The last example 
represents over-specification.&nbsp; We can determine when we are 
over-specifying a semantic type by asking &quot;are we moving from something specific 
back to something general?&quot;&nbsp; For example:</p>
<ul>
	<li>Phone number to country code, area code, exchange and subscriber ID is 
	moving from general to specific.</li>
	<li>country code to &quot;number&quot; is moving from specific to general.</li>
</ul>
<p>This gives us a clearly defined way of deciding when to stop the hierarchy of 
types.</p>
<h4>Rules / Validation</h4>
<p>Country codes, area codes, exchanges -- they all have certain rules, so even 
though they are integers, they have format rules, minimum and maximum length 
constraints, and so forth.&nbsp; We will eventually (but not in this article) 
want to associate a concrete type with a collection of rules from a rule table.&nbsp;
</p>
<p>The more specific we define a semantic type, the more likely it is that we 
will run into representational conflicts, especially cultural ones.&nbsp; Not 
all countries comply with the
<a href="https://en.wikipedia.org/wiki/North_American_Numbering_Plan">North 
American Numbering Plan</a> -- only 24 apparently do so.</p>
<p>Our first semantic types are therefore:</p>
<ul>
	<li>countryCode</li>
	<li>areaCode</li>
	<li>exchange</li>
<li>subscriberId</li>
</ul>
<p>We observe that a semantic type then always terminates in a field we will 
call &quot;value&quot; and furthermore, we note that a concrete semantic type never has 
more than one value field.&nbsp; If it did, it would be a composite type, and we 
would want to break this down into its constituent sub-types.&nbsp; So here we 
have another rule:</p>
<p><i>a concrete semantic type often has only one value field.</i></p>
<p>This may at first seem very strange, counter-intuitive, and inefficient, but 
it allows us to fully express data semantically.&nbsp; Lookup collections 
(key-value pairs) are one exception to this rule.</p>
<p>A second thing that results from a semantic type is that there are often 
placeholder collections with no concrete values.&nbsp; I call these &quot;abstract&quot; 
collections, as they contain only references to child collections.</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void CreateConcreteCollection()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.InstantiateSchema(&quot;{name: 'countryCode'}&quot;);
  sd.InstantiateSchema(schema);
  List&lt;string&gt; collections = sd.GetCollections();
  Assert.IsTrue(collections.Count == 1, &quot;Expected 1 collection.&quot;);
  Assert.IsTrue(collections[0] == &quot;countryCode&quot;, &quot;Collection does not match expected name&quot;);
}</pre>
<p>The workhorse for this implementation is a ridiculous workaround because of a 
bug in 2.2.0 (this kind of bug really leaves a sour taste when it comes to open 
source projects):</p>
<pre>public void CreateCollection(string collectionName)
{
  // This throws a NullReferenceException!
  // See here: https://jira.mongodb.org/browse/CSHARP-1524
  // This is apparently fixed in version 2.2.1
  // db.CreateCollection(collectionName);

  // For now, we use this workaround:

  // As per the documentation: MongoDB creates collections automatically when they are first used, so you only need to call this method if you want to provide non-default options.
  // What we do here is create a collection with a single entry, then delete that item, thus resulting in an empty collection. 
  // While I get the &quot;don't create it until you need it&quot; concept, there are reasons (like my unit tests) for why I want the collection actually physically created.
  var data = new BsonDocument(collectionName, &quot;{Value : 0}&quot;);
  var collection = db.GetCollection&lt;BsonDocument&gt;(collectionName);
  collection.InsertOne(data);
  var result = collection.DeleteOne(new BsonDocument(&quot;_id&quot;, data.Elements.Single(el =&gt; el.Name == &quot;_id&quot;).Value));
}}</pre>
<h3>Create a Hierarchical Semantic Type</h3>
<p>Here we test creating collections from a hierarchy:</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void CreateSpecializedCollection()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.InstantiateSchema(@&quot;
  {
    name: 'phoneNumber', 
    subtypes:
    [
      {name: 'countryCode'},
      {name: 'areaCode'},
      {name: 'exchange'},
      {name: 'subscriberId'},
    ]
  }&quot;);
  sd.InstantiateSchema(schema);
  List&lt;string&gt; collections = sd.GetCollections();
  Assert.IsTrue(collections.Count == 5, &quot;Expected 5 collections.&quot;);
  Assert.IsTrue(collections.Contains(&quot;phoneNumber&quot;));
  Assert.IsTrue(collections.Contains(&quot;countryCode&quot;));
  Assert.IsTrue(collections.Contains(&quot;areaCode&quot;));
  Assert.IsTrue(collections.Contains(&quot;exchange&quot;));
  Assert.IsTrue(collections.Contains(&quot;subscriberId&quot;));
}}</pre>
<p>Again, there's no magic here -- empty collections are created:</p>
<p><img border="0" src="schema2.png" width="171" height="133"></p>
<p>Because these are schema-less document collections, there of course are no 
field definitions.</p>
<h3>Insert Into a Concrete Semantic Type</h3>
<p>Here we test inserting records into a concrete semantic type.&nbsp; The 
backing implementation is very bare-bones, as we still have to write the more 
complicated, and interesting, insertion of a semantic hierarchy.&nbsp; But 
first, the basic test:</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void InsertConcreteTypeTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.InstantiateSchema(@&quot;
  {
    name: 'countryCodeLookup', 
    concreteTypes:
    {
      value: 'System.Int32',
      name: 'System.String'
    }
  }&quot;);

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 1, &quot;Collection should be length of 1.&quot;);

  sd.Insert(schema, &quot;{value: 1, name: 'United States'}&quot;);
  sd.Insert(schema, &quot;{value: 20, name: 'Egypt'}&quot;);
  sd.Insert(schema, &quot;{value: 30, name: 'Greece'}&quot;);

  List&lt;string&gt; json = sd.GetAll(&quot;countryCode&quot;);

  Assert.IsTrue(json[0].Contains(&quot;{ \&quot;value\&quot; : 1, \&quot;name\&quot; : \&quot;United States\&quot; }&quot;));;
  Assert.IsTrue(json[1].Contains(&quot;{ \&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot; }&quot;));
  Assert.IsTrue(json[2].Contains(&quot;{ \&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot; }&quot;));
}</pre>
<p>and the basic implementation (note that it completely ignores the schema):</p>
<pre>public void Insert(Schema schema, string json)
{
  db.GetCollection&lt;BsonDocument&gt;(schema.Name).InsertOne(BsonDocument.Parse(json));
}</pre>
<p><img border="0" src="inserttest.png" width="591" height="289"></p>
<h3>Insert Into a Semantic Hierarchy</h3>
<p>Now, with regards to the above implementation, the astute reader may say, 
&quot;well, isn't the country a semantic type?&quot;&nbsp; Indeed so, so let's create a 
proper semantic hierarchy and write a test for inserting into a hierarchy:</p>
<h4>The Name Collection</h4>
<p>The collection &quot;name&quot; is a strange beast.&nbsp; It is a semantic 
generalization, but it also has a specific meaning -- it is the name of 
something.&nbsp; We humans are all about naming things, Arthur C. Clarke even 
wrote a short story about the human race being created solely for the purpose of 
listing all the names of God, after which the universe ended -- <u>
<a href="http://downlode.org/Etext/nine_billion_names_of_god.html">The Nine 
Billion Names of God</a></u>.&nbsp; Therefore, &quot;name&quot; is a special collection in 
a semantic database, so that entities can be named.</p>
<p>Notice that we're still inserting a flattened hierarchy.&nbsp; We'll 
look at resolving duplicate field names and hierarchical inserts later on.</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void InsertHierarchyTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.InstantiateSchema(@&quot;
  {
    name: 'countryCode', 
    concreteTypes:
    {
      value: 'System.Int32',
    },
    subtypes: 
    [
      {
        name: 'countryName', 
        subtypes: 
        [
          {
            name: 'name', 
            concreteTypes:
            {
              name: 'System.String'
            }
          }
        ]
      }
    ]
  }&quot;);
  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 3, &quot;Collection should be length of 3.&quot;);
  sd.Insert(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 20, name: 'Egypt'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 30, name: 'Greece'}&quot;));


  Assert.IsTrue(json[0].Contains(&quot;{ \&quot;name\&quot; : \&quot;United States\&quot; }&quot;));
  Assert.IsTrue(json[1].Contains(&quot;{ \&quot;name\&quot; : \&quot;Egypt\&quot; }&quot;));
  Assert.IsTrue(json[2].Contains(&quot;{ \&quot;name\&quot; : \&quot;Greece\&quot; }&quot;));

  json = sd.GetAll(&quot;countryName&quot;);
  Assert.IsTrue(json.Count==3);

  json = sd.GetAll(&quot;countryCode&quot;);
  Assert.IsTrue(json[0].Contains(&quot;{ \&quot;value\&quot; : 1&quot;));;
  Assert.IsTrue(json[1].Contains(&quot;{ \&quot;value\&quot; : 20&quot;));
  Assert.IsTrue(json[2].Contains(&quot;{ \&quot;value\&quot; : 30&quot;));}}</pre>
<p><img border="0" src="key-small.jpg" width="94" height="33"></p>
<p>Notice the hierarchy we are creating, and that the middle semantic type, &quot;countryName&quot;, 
does not have any concrete values.&nbsp; Why do this?&nbsp; Because 
semantically, it allows us to query two different things:</p>
<ol>
	<li>Give me all the names of things that have names/li>
	<li>GGive me all the names of countries</li>
</ol>
<p>Notice how the top level implementation has become a bit more complicated, 
recursing into the schema structure, removing concrete types as we recurse, and 
adding reference ID's to parent's JSON object.</p>
<pre>public string nsert(Schema schema, JObject jobj)
{
  string id = null;

  if (schema.IsConcreteType)
  {
    id = Insert(schema.Name, jobj);
  }
  else
  {
    JObject currentObject = GetConcreteObjects(schema, jobj);
    JObject subjobj = RemoveCurrentConcreteObjects(schema, jobj);
    RecurseIntoSubtypes(schema, currentObject, subjobj);
    id = Insert(schema.Name, currentObject);
  }}

  return id;
}</pre>
<h3>Insert Duplicates Tests</h3>
<p>We next delve into some further complexity: in a semantic database, we never 
duplicate a record, regardless of where it is in the hierarchy.&nbsp; Instead, 
we increment a reference count.&nbsp; </p>
<p><img border="0" src="key-small.jpg" width="94" height="33"></p>
<p>In a semantic database, this fully normalizes the value associated with a 
specific semantic type, such that we are never need to compare the values 
between two semantic hierarchies because we rely on the normalization the data 
in the semantic schema to create the &quot;joins&quot; between different semantic 
structures.&nbsp; This works well when the entire schema for a database is well 
designed but does not prevent us from having to do value comparisons between two 
databases.</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void InsertDuplicateHierarchyTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.InstantiateSchema(@&quot;
  {
    name: 'countryCode', 
    concreteTypes:
    {
      value: 'System.Int32',
    },
    subtypes: 
    [
      {
        name: 'countryName', 
        subtypes: 
        [
          {
            name: 'name', 
            concreteTypes:
            {
              name: 'System.String'
            }
          }
        ]
      }
    ]
  }&quot;);

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 3, &quot;Collection should be length of 3.&quot;);
  sd.Insert(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));

  List&lt;string&gt; json;

  json = sd.GetAll(&quot;name&quot;);
  Assert.IsTrue(json.Count == 1);
  Assert.IsTrue(json[0].Contains(&quot;\&quot;name\&quot; : \&quot;United States\&quot;&quot;));

  json = sd.GetAll(&quot;countryName&quot;);
  Assert.IsTrue(json.Count == 1);

  json = sd.GetAll(&quot;countryCode&quot;);
  Assert.IsTrue(json.Count == 1);
  Assert.IsTrue(json[0].Contains(&quot;\&quot;value\&quot; : 1&quot;));

  // Duplicate insert:
  sd.Insert(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  json = sd.GetAll(&quot;name&quot;);
  Assert.IsTrue(json.Count == 1);
  Assert.IsTrue(json[0].Contains(&quot;\&quot;_ref\&quot; : 2 }&quot;));

  json = sd.GetAll(&quot;countryName&quot;);
  Assert.IsTrue(json.Count == 1);
  Assert.IsTrue(json[0].Contains(&quot;\&quot;_ref\&quot; : 2 }&quot;));

  json = sd.GetAll(&quot;countryCode&quot;);
  Assert.IsTrue(json.Count == 1);
  Assert.IsTrue(json[0].Contains(&quot;\&quot;_ref\&quot; : 2 }&quot;));
}</pre>
<p>The insert method is refactored again to get this test to pass, but you 
should see a pattern emerging here between a concrete semantic instance 
insertion and a hierarchy insertion:</p>
<pre>public string Insert(Schema schema, JObject jobj)
{
  string id = null;

  if (schema.IsConcreteType)
  {
    int refCount;

    if (IsDuplicate(schema.Name, jobj, out id, out refCount))
    {
      IncrementRefCount(schema.Name, id, refCount);
    }
    else
    {
      JObject withRef = AddRef1(jobj);
      id = Insert(schema.Name, withRef);
    }
  }
  else
  {
    JObject currentObject = GetConcreteObjects(schema, jobj);
    JObject subjobj = RemoveCurrentConcreteObjects(schema, jobj);
    RecurseIntoSubtypes(schema, currentObject, subjobj);
    int refCount;

    if (IsDuplicate(schema.Name, currentObject, out id, out refCount))
    {
      IncrementRefCount(schema.Name, id, refCount);
    }
    else
    {
      JObject withRef = AddRef1(currentObject);
      id = Insert(schema.Name, withRef);
    }
  }

  return id;
}</pre>
<h3>Concrete Semantic Query Test</h3>
<p>This <code>Query</code> call for the a concrete semantic type is really nothing more than 
a call to the <code>GetAll()</code> method, but we test it here anyways.</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestClass]
public class QueryTests
{
  [TestMethod]
  public void ConcreteQueryTest()
  {
    SemanticDatabase sd = Helpers.CreateCleanDatabase();
    Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
    Schema schema = Helpers.InstantiateSchema(@&quot;
    {
      name: 'countryCodeLookup', 
      concreteTypes:
      {
        value: 'System.Int32',
        name: 'System.String'
      }
    }&quot;);

    sd.InstantiateSchema(schema);
    Assert.IsTrue(sd.GetCollections().Count == 1, &quot;Collection should be length of 1.&quot;);
  
    sd.Insert(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));
    List&lt;JObject&gt; records = sd.Query(schema);

    Assert.IsTrue(records.Count == 1);
    Assert.IsTrue(records[0].Contains(&quot;{\&quot;value\&quot;:1,\&quot;name\&quot;:\&quot;United States\&quot;&quot;));
  }
}</pre>
<h3>Hierarchical Semantic Query Test</h3>
<h4>Client-Side</h4>
<p>This query returns flattened records (so much for a document database!) of a 
semantic instance at the specified hierarchy.</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void HierarchicalQueryTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.InstantiateSchema(@&quot;
  {
    name: 'countryCode', 
    concreteTypes:
    {
      value: 'System.Int32',
    },
    subtypes: 
    [
      {
        name: 'countryName', 
        subtypes: 
        [
          {
            name: 'name', 
            concreteTypes:
            {
              name: 'System.String'
            }
          }
        ]
      }
    ]
  }&quot;);

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 3, &quot;Collection should be length of 3.&quot;);
  sd.Insert(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 20, name: 'Egypt'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 30, name: 'Greece'}&quot;));

  List&lt;BsonDocument&gt; json;

  json = sd.Query(schema);
  Assert.IsTrue(json.Count == 3);

  Assert.IsTrue(json[0].ToString().Contains(&quot;\&quot;value\&quot; : 1, \&quot;name\&quot; : \&quot;United States\&quot;&quot;));
  Assert.IsTrue(json[1].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
  Assert.IsTrue(json[2].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));
}</pre>
<p>We can refactor the query for a client-side implementation:</p>
<pre>public List&lt;BsonDocument&gt; Query(Schema schema, string id = null)
{
  List&lt;BsonDocument&gt; records = new List&lt;BsonDocument&gt;();

  records = GetAll(schema.Name, id);

  foreach (BsonDocument record in records)
  {
    record.Remove(&quot;_ref&quot;);

    foreach (Schema subtype in schema.Subtypes)
    {
      string childIdName = subtype.Name + &quot;Id&quot;;
      // Remove the FK ID, as we don't want it in the final recordset
      string childId = record[childIdName].ToString();
      record.Remove(childIdName);
      List&lt;BsonDocument&gt; childRecords = Query(subtype, childId);

      // TODO: Assert that childRecords &lt;= 1, and we know only one child record exists because we don't allow duplicates.
      if (childRecords.Count == 1)
      {
        childRecords[0].Elements.ForEach(p =&gt; record.Add(p.Name, childRecords[0][p.Name]));
      }
    }
  }

  return records;
}</pre>
<h4>Server-Side</h4>
<p>Conversely, we could build a MongoDB query to run the query server-side.&nbsp; In the Mongo console, it 
would look like this:</p>
<pre>db.countryCode.aggregate(
  {$lookup: {from: &quot;countryName&quot;, localField:&quot;countryNameId&quot;, foreignField: &quot;_id&quot;, as: &quot;countryName&quot;} },
  {$unwind: &quot;$countryName&quot;},
  {$lookup: {from: &quot;name&quot;, localField:&quot;countryName.nameId&quot;, foreignField: &quot;_id&quot;, as: &quot;name&quot;} },
  {$unwind: &quot;$name&quot;},
  {$project: {&quot;value&quot;: &quot;$value&quot;, &quot;name&quot;: &quot;$name.name&quot;, &quot;_id&quot;:0} }
)</pre>
<p>See my article on
<a href="http://www.codeproject.com/Articles/1077839/Working-with-MongoDBs-lookup-Aggregator">
Working with MongoDB's $lookup Aggregator</a> to learn more about how to use 
<code>$lookup</code> for joining collections.</p>
<p>We'll extend our test to test server-side as well:</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>json = sd.QueryServerSide(schema);
Assert.IsTrue(json.Count == 3);

Assert.IsTrue(json[0].ToString().Contains(&quot;\&quot;value\&quot; : 1, \&quot;name\&quot; : \&quot;United States\&quot;&quot;));
Assert.IsTrue(json[1].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
Assert.IsTrue(json[2].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));</pre>
<p>We execute a server-side query, building the aggregators by inspecting the schema:</p>
<pre>public List&lt;BsonDocument&gt; QueryServerSide(Schema schema, string id = null)
{
  var collection = db.GetCollection&lt;BsonDocument&gt;(schema.Name);
  List&lt;string&gt; projections = new List&lt;string&gt;();
  List&lt;string&gt; pipeline = BuildQueryPipeline(schema, String.Empty, projections);
  pipeline.Add(String.Format(&quot;{{$project: {{{0}, '_id':0}} }}&quot;, String.Join(&quot;,&quot;, projections)));
  var aggr = collection.Aggregate();
  pipeline.ForEach(s =&gt; aggr = aggr.AppendStage&lt;BsonDocument&gt;(s));
  List&lt;BsonDocument&gt; records = aggr.ToList();

  return records;
}</pre>
<p>and:</p>
<pre>protected List&lt;string&gt; BuildQueryPipeline(Schema schema, string parentName, List&lt;string&gt; projections)
{
  List&lt;string&gt; pipeline = new List&lt;string&gt;();

  schema.ConcreteTypes.ForEach(kvp =&gt; projections.Add(String.Format(&quot;'{0}':'${1}'&quot;, kvp.Key, parentName + kvp.Key)));

  foreach (Schema subtype in schema.Subtypes)
  {
    pipeline.Add(String.Format(&quot;{{$lookup: {{from: '{0}', localField:'{2}{1}', foreignField: '_id', as: '{0}'}} }},&quot;, subtype.Name, subtype.Name + &quot;Id&quot;, parentName));
    pipeline.Add(String.Format(&quot;{{$unwind: '${0}'}}&quot;, subtype.Name));
    List&lt;string&gt; subpipeline = BuildQueryPipeline(subtype, subtype.Name + &quot;.&quot;, projections);

    if (subpipeline.Count &gt; 0)
    {
      pipeline[pipeline.Count - 1] = pipeline.Last() + &quot;,&quot;;
      pipeline.AddRange(subpipeline);
    }
  }

  return pipeline;
}</pre>
<h3>Delete Tests</h3>
<h4>Delete Concrete Instance Test</h4>
<p>Here, we test deleting a concrete instance:</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void DeleteSingleInstanceTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.GetSimpleTestSchema();

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 1, &quot;Collection should be length of 1.&quot;);

  sd.Insert(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 20, name: 'Egypt'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 30, name: 'Greece'}&quot;));

  List&lt;BsonDocument&gt; bson = sd.GetAll(&quot;countryCodeLookup&quot;);
  Assert.IsTrue(bson.Count == 3);

  sd.Delete(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));

  bson = sd.GetAll(&quot;countryCodeLookup&quot;);
  Assert.IsTrue(bson.Count == 2);

  Assert.IsTrue(bson[0].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
  Assert.IsTrue(bson[1].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));
}</pre>
<p>The implementation for a deletion is very similar to an insert, where we 
decrement the reference count if greater than 1, otherwise we delete the 
collection record:</p>
<pre>protected string Delete(Schema schema, BsonDocument doc)
{
  string id = null;

  if (schema.IsConcreteType)
  {
    int refCount = GetRefCount(schema.Name, doc, out id);

    if (refCount == 1)
    {
      Delete(schema.Name, id);
    }
    else
    {
      DecrementRefCount(schema.Name, id, refCount);
    }
  }
  else
  {
    BsonDocument currentObject = GetConcreteObjects(schema, doc);
    BsonDocument subjobj = RemoveCurrentConcreteObjects(schema, doc);
    DeleteRecurseIntoSubtypes(schema, currentObject, subjobj);
    int refCount = GetRefCount(schema.Name, currentObject, out id);

    if (refCount == 1)
    {
      Delete(schema.Name, id);
    }
    else
    {
      DecrementRefCount(schema.Name, id, refCount);
    }
  }

  return id;
}</pre>
<p>Since the above was so similar to the insert process, I decided to write the 
entire implementation first, then the additional tests!</p>
<h4>Delete Multiple Reference Test</h4>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void DeleteMultipleReferenceTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.GetSimpleTestSchema();

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 1, &quot;Collection should be length of 1.&quot;);

  sd.Insert(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 20, name: 'Egypt'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 30, name: 'Greece'}&quot;));

  // second reference:
  sd.Insert(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));

  List&lt;BsonDocument&gt; bson = sd.GetAll(&quot;countryCodeLookup&quot;);
  Assert.IsTrue(bson.Count == 3);

  // First delete:
  sd.Delete(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));

  bson = sd.GetAll(&quot;countryCodeLookup&quot;);
  Assert.IsTrue(bson.Count == 3);

  Assert.IsTrue(bson[0].ToString().Contains(&quot;\&quot;value\&quot; : 1, \&quot;name\&quot; : \&quot;United States\&quot;&quot;));
  Assert.IsTrue(bson[1].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
  Assert.IsTrue(bson[2].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));

  // Second delete:
  sd.Delete(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));

  bson = sd.GetAll(&quot;countryCodeLookup&quot;);
  Assert.IsTrue(bson.Count == 2);

  Assert.IsTrue(bson[0].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
  Assert.IsTrue(bson[1].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));
}</pre>
<h4>Delete Hierarchy Test</h4>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void DeleteHierarchyTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.GetTestHierarchySchema();

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 3, &quot;Collection should be length of 3.&quot;);
  sd.Insert(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 20, name: 'Egypt'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 30, name: 'Greece'}&quot;));

  List&lt;BsonDocument&gt; bson;

  bson = sd.Query(schema);
  Assert.IsTrue(bson.Count == 3);

  sd.Delete(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));

  bson = sd.Query(schema);
  Assert.IsTrue(bson.Count == 2);

  Assert.IsTrue(bson[0].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
  Assert.IsTrue(bson[1].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));
}</pre>
<h4>Delete Multiple Reference Hierarchy Test</h4>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void DeleteMultipleReferenceHierarchyTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.GetTestHierarchySchema();

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 3, &quot;Collection should be length of 3.&quot;);
  sd.Insert(schema, JObject.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 20, name: 'Egypt'}&quot;));
  sd.Insert(schema, JObject.Parse(&quot;{value: 30, name: 'Greece'}&quot;));

  // Insert a record that re-uses the country name.
  sd.Insert(schema, JObject.Parse(&quot;{value: 2, name: 'United States'}&quot;));

  List&lt;BsonDocument&gt; bson;

  bson = sd.Query(schema);
  Assert.IsTrue(bson.Count == 4);

  // Delete just the re-use high-level type.
  sd.Delete(schema, JObject.Parse(&quot;{value: 2, name: 'United States'}&quot;));

  bson = sd.Query(schema);
  Assert.IsTrue(bson.Count == 3);

  Assert.IsTrue(bson[0].ToString().Contains(&quot;\&quot;value\&quot; : 1, \&quot;name\&quot; : \&quot;United States\&quot;&quot;));
  Assert.IsTrue(bson[1].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
  Assert.IsTrue(bson[2].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));
}</pre>
<h4>The Missing Test</h4>
<p>There is an important test that is missing:</p>
<pre>// TODO: We should not be able to delete a sub-type if it is referenced by
// a super-type. We need a master schema to know whether a sub-type has a super-type somewhere,
// or we need to ask the DB for fields of the form &quot;[subtype]Id&quot;, which would indicate that the
// subtype is an FK in a supertype.</pre>
<p>In terms of a &quot;master schema&quot;, since a NoSQL database is schema-less, this 
isn't necessarily easy to extract from the database itself, however tools like
<a href="https://github.com/variety/variety">Variety</a>, a schema analyzer, 
look like a really good start.&nbsp; Of course, to determine the schema, the 
tool has to actually inspect the <i>records</i> in each collection.&nbsp; 
Ideally, we should have a separate master schema, but I haven't implemented that 
at the time of this writing.</p>
<h3>Update Tests</h3>
<p>Updates are the most complicated / interesting:</p>
<ol>
	<li>The complete set of values for the original semantic type must be 
	provided as well as the new values -- we can't actually just update a value 
	based on some primary key.</li>
	<li>If there are no other references to the semantic type, the concrete 
	types can simply be updated.</li>
	<li>If there are other references:<ol>
		<li>the reference count for the current type must be decremented</li>
		<li>a new instance of the type must be inserted</li>
		<li>the super-type's &quot;foreign key&quot; reference must be updated</li>
		<li>this process needs to recurse upwards through the hierarchy</li>
	</ol>
</li>
</ol>
<p>Point #1 is one of the most distinguishing features of a semantic database as 
compared to a typical relational database.</p>
<h4>Update a Concrete Semantic Type Test</h4>
<p>This is the simplest test, where a concrete semantic type (one with no 
sub-types) is updated:</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>[TestMethod]
public void UpdateConcreteTypeTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.GetSimpleTestSchema();

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 1, &quot;Collection should be length of 1.&quot;);

  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 20, name: 'Egypt'}&quot;));
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 30, name: 'Greece'}&quot;));

  List&lt;BsonDocument&gt; bson = sd.GetAll(&quot;countryCodeLookup&quot;);
  Assert.IsTrue(bson.Count == 3);

  sd.Update(schema, BsonDocument.Parse(&quot;{value: 1, name: 'United States'}&quot;), BsonDocument.Parse(&quot;{value: 1, name: 'United States of America'}&quot;));
  
  bson = sd.GetAll(&quot;countryCodeLookup&quot;);
  Assert.IsTrue(bson.Count == 3);

  Assert.IsTrue(bson[0].ToString().Contains(&quot;\&quot;value\&quot; : 1, \&quot;name\&quot; : \&quot;United States of America\&quot;&quot;));
  Assert.IsTrue(bson[1].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
  Assert.IsTrue(bson[2].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));
}</pre>
<h4>Update the Bottom of a Semantic Hierarchy Test</h4>
<p>Here, we do a very similar test as above, except this time we test updating 
the bottom element of a hierarchy:</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>/// &lt;summary&gt;
/// Test changing a concrete value at the bottom of the hierarcy.
/// &lt;/summary&gt;
[TestMethod]
public void UpdateBottomHierarchySingleReferenceTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.GetTestHierarchySchema();

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 3, &quot;Collection should be length of 3.&quot;);
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 20, name: 'Egypt'}&quot;));
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 30, name: 'Greece'}&quot;));

  List&lt;BsonDocument&gt; bson;

  bson = sd.Query(schema);
  Assert.IsTrue(bson.Count == 3);

  // This tests updating the bottom of the hierarchy, and since there are no other references, we can update the only instance.
  sd.Update(schema, BsonDocument.Parse(&quot;{value: 1, name: 'United States'}&quot;), BsonDocument.Parse(&quot;{value: 1, name: 'United States of America'}&quot;));
  bson = sd.Query(schema);
  Assert.IsTrue(bson.Count == 3);

  Assert.IsTrue(bson[0].ToString().Contains(&quot;\&quot;value\&quot; : 1, \&quot;name\&quot; : \&quot;United States of America\&quot;&quot;));
  Assert.IsTrue(bson[1].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
  Assert.IsTrue(bson[2].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));
}</pre>
<h4>Update the Top of the Hierarchy Test</h4>
<p>Here, we test updating a concrete value at top of the semantic type 
hierarchy:</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>/// &lt;summary&gt;
/// Test changing the country code (the value field), which is at the top of the hierarchy.
/// &lt;/summary&gt;
[TestMethod]
public void UpdateTopHierarchySingleReferenceTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.GetTestHierarchySchema();

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 3, &quot;Collection should be length of 3.&quot;);
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 20, name: 'Egypt'}&quot;));
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 30, name: 'Greece'}&quot;));

  List&lt;BsonDocument&gt; bson;

  bson = sd.Query(schema);
  Assert.IsTrue(bson.Count == 3);

  // This tests updating the top of the hierachy, changing the country code from 1 to 3.
  sd.Update(schema, BsonDocument.Parse(&quot;{value: 1}&quot;), BsonDocument.Parse(&quot;{value: 3}&quot;));
  bson = sd.Query(schema);
  Assert.IsTrue(bson.Count == 3);

  Assert.IsTrue(bson[0].ToString().Contains(&quot;\&quot;value\&quot; : 3, \&quot;name\&quot; : \&quot;United States\&quot;&quot;));
  Assert.IsTrue(bson[1].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
  Assert.IsTrue(bson[2].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));
}</pre>
<h4>Update Multiple Reference Test</h4>
<p>Here, we test updating the bottom of the hierarchy when a concrete value is 
referenced by two separate semantic instances:</p>
<p><img border="0" src="unittest.png" width="14" height="32"></p>
<pre>/// &lt;summary&gt;
/// Test changing the country name when there are two references to the same country.
/// &lt;/summary&gt;
[TestMethod]
public void UpdateBottomHierarchyMultipleReferenceTest()
{
  SemanticDatabase sd = Helpers.CreateCleanDatabase();
  Assert.IsTrue(sd.GetCollections().Count == 0, &quot;Collection should be 0 length.&quot;);
  Schema schema = Helpers.GetTestHierarchySchema();

  sd.InstantiateSchema(schema);
  Assert.IsTrue(sd.GetCollections().Count == 3, &quot;Collection should be length of 3.&quot;);
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 1, name: 'United States'}&quot;));
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 20, name: 'Egypt'}&quot;));
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 30, name: 'Greece'}&quot;));
  sd.Insert(schema, BsonDocument.Parse(&quot;{value: 40, name: 'United States'}&quot;)); // The country name is in error.

  List&lt;BsonDocument&gt; bson;

  bson = sd.Query(schema);
  Assert.IsTrue(sd.GetAll(&quot;name&quot;).Count == 3); // &quot;United States&quot; has a ref count of 2
  Assert.IsTrue(bson.Count == 4);

  // Fix the country name:
  sd.Update(schema, BsonDocument.Parse(&quot;{value: 40, name: 'United States'}&quot;), BsonDocument.Parse(&quot;{value: 40, name: 'Romania'}&quot;));
  bson = sd.Query(schema);
  Assert.IsTrue(sd.GetAll(&quot;name&quot;).Count == 4); // Now we should have four unique country names
  Assert.IsTrue(bson.Count == 4);

  Assert.IsTrue(bson[0].ToString().Contains(&quot;\&quot;value\&quot; : 1, \&quot;name\&quot; : \&quot;United States\&quot;&quot;));
  Assert.IsTrue(bson[1].ToString().Contains(&quot;\&quot;value\&quot; : 20, \&quot;name\&quot; : \&quot;Egypt\&quot;&quot;));
  Assert.IsTrue(bson[2].ToString().Contains(&quot;\&quot;value\&quot; : 30, \&quot;name\&quot; : \&quot;Greece\&quot;&quot;));
  Assert.IsTrue(bson[3].ToString().Contains(&quot;\&quot;value\&quot; : 40, \&quot;name\&quot; : \&quot;Romania\&quot;&quot;));
}</pre>
<h4>Implementation</h4>
<p>The high level implementation is a recursive process in which we determine 
whether a record's fields can be updated (there is only one reference) or 
whether the reference count needs to be decremented and a new instance created, 
which percolates back up the hierarchy.&nbsp; We also have a special case 
handler for partial semantic types -- one in which the flattened data does not 
extend down to the lowest sub-type, as is the case in the &quot;update the top of the 
hierarchy&quot; test above.&nbsp; Notice the complexity of this operation and the 
reliance on the _id for each record as we drill into the hierarchy, which is 
necessary to determine whether, on unwinding from the recursion, a super-type's 
reference needs to be updated.</p>
<pre>protected string Update(Schema schema, BsonDocument docOriginal, BsonDocument docNew, string schemaId)
{
  string id = null;

  if (schema.IsConcreteType)
  {
    int refCount = GetRefCount(schema.Name, docOriginal, out id);

    if (refCount == 1)
    {
      Update(schema.Name, id, docOriginal, docNew);
    }
    else
    {
      // We never have 0 references, because this would have meant decrementing from 1, which would instead trigger and update above.
      DecrementRefCount(schema.Name, id, refCount);
      id = InternalInsert(schema, docNew);
    }
  }
  else
  {
    BsonDocument currentOriginalObject = GetConcreteObjects(schema, docOriginal);
    BsonDocument record = null;

    if (schemaId == null)
    {
      // We must use the concrete objects to determine the record.
      // If there are no concrete objects, we have an error.
      // There should be a single unique record for the concrete object.
      if (currentOriginalObject.Elements.Count() == 0)
      {
        throw new SemanticDatabaseException(&quot;Cannot update the a semantic type starting with the abstract type &quot; + schema.Name);
      }

      record = GetRecord(schema.Name, currentOriginalObject);

      if (record == null)
      {
        throw new SemanticDatabaseException(&quot;The original record for the semantic type &quot; + schema.Name + &quot; cannot be found.\r\nData: &quot; + currentOriginalObject.ToString());
      }
    }
    else
    {
      // We use the subtype id to get the record.
      record = GetRecord(schema.Name, new BsonDocument(&quot;_id&quot;, new ObjectId(schemaId)));

      if (record == null)
      {
        throw new SemanticDatabaseException(&quot;An instance of &quot; + schema.Name + &quot; with _id = &quot; + schemaId + &quot; does not exist!&quot;);
      }
    }

    BsonDocument subOriginalJobj = RemoveCurrentConcreteObjects(schema, docOriginal);

    if (subOriginalJobj.Elements.Count() == 0)
    {
      // There is nothing further to do, as we're not changing anything further in the hierarchy.
      // Update the current concrete types.
      id = record.Elements.Single(el =&gt; el.Name == &quot;_id&quot;).Value.ToString();
      int refCount = record.Elements.Single(el =&gt; el.Name == &quot;_ref&quot;).Value.ToInt32();

      if (refCount == 1)
      {
        BsonDocument currentNewObject = GetConcreteObjects(schema, docNew);
        Update(schema.Name, id, record, currentNewObject);
      }
      else
      {
        // TODO: THIS CODE PATH IS NOT TESTED!
        // Now we have a problem -- something else is referencing this record other than our current hierarch, 
        // but we don't know what. But we're updating this particular type instance. 
        // Do all the super-types reflect this change in the subtype? We'll assume no.
        // Only this hierarchy gets updated.
        DecrementRefCount(schema.Name, id, refCount);
        id = InternalInsert(schema, docNew);

        // Otherwise:
        // All supertypes referencing this hierarchy get updated.
        //BsonDocument currentNewObject = GetConcreteObjects(schema, docNew);
        //Update(schema.Name, id, record, currentNewObject);
      }
    }
    else
    {
      BsonDocument currentNewObject = GetConcreteObjects(schema, docNew);
      BsonDocument subNewJobj = RemoveCurrentConcreteObjects(schema, docNew);
      UpdateRecurseIntoSubtypes(schema, record, currentOriginalObject, subOriginalJobj, currentNewObject, subNewJobj);
      id = record.Elements.Single(el =&gt; el.Name == &quot;_id&quot;).Value.ToString();
      int refCount = record.Elements.Single(el =&gt; el.Name == &quot;_ref&quot;).Value.ToInt32();

      if (refCount == 1)
      {
        Update(schema.Name, id, record, currentNewObject);
      }
      else
      {
        // We never have 0 references, because this would have meant decrementing from 1, which would instead trigger and update above.
        DecrementRefCount(schema.Name, id, refCount);
        id = InternalInsert(schema, docNew);
      }
    }
  }

  return id;
}</pre>
<h2>Conclusion</h2>
<p>So far so good -- although there are some TODO's and gaps in the path 
testing, this is sufficient to move forward with Part II.&nbsp; I realize the 
ideas presented here are probably crazy, and this article is somewhat boring 
because it's basically just unit tests.&nbsp; However, things should get a bit 
more exciting in Part II, and certainly in Part III!</p>

</body>

</html>